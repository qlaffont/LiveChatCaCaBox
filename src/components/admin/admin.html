<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LiveChat CaCaBox - Admin Interface</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Socket.IO Client -->
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>

  <!-- Vue.js 3 -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

  <style>
    [v-cloak] {
      display: none;
    }

    .media-card {
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .media-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    }
  </style>
</head>

<body class="bg-gray-100 min-h-screen">
  <div id="app" v-cloak>
    <!-- Authentication Screen -->
    <div v-if="!isAuthenticated" class="flex items-center justify-center min-h-screen">
      <div class="bg-white p-8 rounded-lg shadow-lg max-w-md w-full">
        <h1 class="text-3xl font-bold text-center mb-6 text-indigo-600">LiveChat CaCaBox</h1>
        <h2 class="text-xl text-center mb-6 text-gray-700">Admin Interface</h2>

        <form @submit.prevent="authenticate">
          <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold mb-2" for="username">
              Username
            </label>
            <input v-model="username" type="text" id="username"
              class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-indigo-500"
              placeholder="Enter your username" required />
          </div>

          <button type="submit"
            class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline transition"
            :disabled="isConnecting">
            {{ isConnecting ? 'Connecting...' : 'Connect' }}
          </button>
        </form>

        <p v-if="errorMessage" class="mt-4 text-red-500 text-sm text-center">
          {{ errorMessage }}
        </p>
      </div>
    </div>

    <!-- Main Interface -->
    <div v-else class="container mx-auto p-4 pb-20 relative">
      <!-- Media Playback Modal -->
      <div v-if="selectedMedia" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4"
        @click.self="closePlayModal">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-4xl overflow-hidden relative">
          <!-- Close Button -->
          <button @click="closePlayModal"
            class="absolute top-2 right-2 text-white bg-black bg-opacity-50 rounded-full w-8 h-8 flex items-center justify-center hover:bg-opacity-70 transition">
            &times;
          </button>

          <!-- Preview -->


          <!-- Content -->
          <div class="p-6">
            <h3 class="text-lg font-bold text-gray-800 mb-4">Play Media</h3>

            <label class="block text-sm font-semibold text-gray-700 mb-2">Add a Message (Optional)</label>
            <textarea v-model="playText" placeholder="Start typing..." rows="3"
              class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500 mb-4"
              ref="playInput" @keyup.enter.ctrl="confirmPlay"></textarea>

            <div class="flex gap-3 mb-4">
              <!-- Canvas Editor -->
              <div class="w-2/3 bg-gray-900 rounded-lg overflow-hidden relative aspect-video" ref="canvasContainer">
                <!-- TV Frame Decoration -->
                <div class="absolute inset-x-0 bottom-0 h-4 bg-gray-800 z-10 flex items-center justify-center">
                  <div class="w-16 h-1 bg-blue-500 rounded-full opacity-50"></div>
                </div>

                <!-- Draggable Box -->
                <div
                  class="absolute bg-indigo-500 bg-opacity-80 border-2 border-white rounded shadow-lg cursor-move flex items-center justify-center group touch-none select-none transition-colors hover:bg-opacity-90 active:bg-indigo-600"
                  :style="{ 
                         left: mediaPos.x + '%', 
                         top: mediaPos.y + '%', 
                         width: mediaPos.w + '%', 
                         height: mediaPos.h + '%' 
                       }" @mousedown="startDrag">

                  <!-- Resize Handles -->
                  <!-- Top-Left -->
                  <div
                    class="absolute -top-1.5 -left-1.5 w-3 h-3 bg-white rounded-full cursor-nw-resize z-20 opacity-0 group-hover:opacity-100 transition-opacity"
                    @mousedown.stop="startResize('tl')"></div>
                  <!-- Top-Right -->
                  <div
                    class="absolute -top-1.5 -right-1.5 w-3 h-3 bg-white rounded-full cursor-ne-resize z-20 opacity-0 group-hover:opacity-100 transition-opacity"
                    @mousedown.stop="startResize('tr')"></div>
                  <!-- Bottom-Left -->
                  <div
                    class="absolute -bottom-1.5 -left-1.5 w-3 h-3 bg-white rounded-full cursor-sw-resize z-20 opacity-0 group-hover:opacity-100 transition-opacity"
                    @mousedown.stop="startResize('bl')"></div>
                  <!-- Bottom-Right -->
                  <div
                    class="absolute -bottom-1.5 -right-1.5 w-3 h-3 bg-white rounded-full cursor-se-resize z-20 opacity-0 group-hover:opacity-100 transition-opacity"
                    @mousedown.stop="startResize('br')"></div>

                  <!-- Media Info -->
                  <div
                    class="text-white text-xs font-bold px-2 py-1 bg-black bg-opacity-50 rounded pointer-events-none truncate max-w-full">
                    {{ selectedMedia.filename }}
                  </div>
                </div>

                <!-- Grid Lines (Background) -->
                <div class="absolute inset-0 pointer-events-none opacity-20"
                  style="background-image: linear-gradient(#4a5568 1px, transparent 1px), linear-gradient(90deg, #4a5568 1px, transparent 1px); background-size: 25% 25%;">
                </div>
              </div>

              <!-- Controls -->
              <div class="w-1/3 flex flex-col gap-2">
                <div class="bg-gray-100 p-3 rounded">
                  <h4 class="font-bold text-xs text-gray-500 uppercase mb-2">Presets</h4>
                  <div class="grid grid-cols-2 gap-2">
                    <button @click="applyPreset('fullscreen')"
                      class="bg-white border hover:bg-gray-50 text-xs py-1 rounded">Fullscreen</button>
                    <button @click="applyPreset('center')"
                      class="bg-white border hover:bg-gray-50 text-xs py-1 rounded">Center</button>
                    <button @click="applyPreset('corner-br')"
                      class="bg-white border hover:bg-gray-50 text-xs py-1 rounded">Corner BR</button>
                    <button @click="applyPreset('pip')"
                      class="bg-white border hover:bg-gray-50 text-xs py-1 rounded">PIP</button>
                  </div>
                </div>

                <div class="bg-gray-100 p-3 rounded flex-1">
                  <h4 class="font-bold text-xs text-gray-500 uppercase mb-2">Position</h4>
                  <div class="grid grid-cols-2 gap-2 text-xs">
                    <div>
                      <span class="block text-gray-500">X</span>
                      <input type="number" v-model.number="mediaPos.x" class="w-full border rounded px-1" min="0"
                        max="100">
                    </div>
                    <div>
                      <span class="block text-gray-500">Y</span>
                      <input type="number" v-model.number="mediaPos.y" class="w-full border rounded px-1" min="0"
                        max="100">
                    </div>
                    <div>
                      <span class="block text-gray-500">W</span>
                      <input type="number" v-model.number="mediaPos.w" class="w-full border rounded px-1" min="0"
                        max="100">
                    </div>
                    <div>
                      <span class="block text-gray-500">H</span>
                      <input type="number" v-model.number="mediaPos.h" class="w-full border rounded px-1" min="0"
                        max="100">
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="flex gap-3">
              <button @click="closePlayModal"
                class="flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 transition">
                Cancel
              </button>
              <button @click="confirmPlay"
                class="flex-1 px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition font-bold">
                Play Now
              </button>
            </div>
            <p class="text-xs text-gray-500 mt-2 text-center">Tip: Ctrl+Enter to play</p>
          </div>
        </div>
      </div>
      <!-- Header -->
      <!-- Header -->
      <div class="bg-white rounded-lg shadow-md p-4 mb-6 flex flex-col md:flex-row justify-between items-center gap-4">
        <div>
          <h1 class="text-2xl font-bold text-indigo-600">LiveChat CaCaBox Admin</h1>
          <p class="text-gray-600">Welcome, {{ username }}!</p>
        </div>

        <div class="flex items-center gap-3">
          <div class="flex flex-col">
            <label class="text-xs font-semibold text-gray-500 uppercase">Guild / Room ID</label>
            <input v-model="guildId" type="password"
              class="px-3 py-1 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500 bg-gray-50"
              placeholder="1183396070823313418" title="The Discord Guild ID or Room Name (must match bot config)" />
          </div>

          <button @click="logout" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded transition ml-2">
            Logout
          </button>
        </div>
      </div>

      <!-- Tabs Navigation -->
      <div class="bg-white rounded-lg shadow-md mb-6">
        <div class="flex border-b">
          <button v-for="tab in tabs" :key="tab.id" @click="activeTab = tab.id" :class="[
              'flex-1 py-3 px-4 text-center font-semibold transition',
              activeTab === tab.id
                ? 'border-b-2 border-indigo-600 text-indigo-600'
                : 'text-gray-600 hover:text-indigo-600'
            ]">
            {{ tab.icon }} {{ tab.name }}
          </button>
        </div>
      </div>

      <!-- Tab Content -->
      <div class="bg-white rounded-lg shadow-md p-6">
        <!-- Media Library Tab -->
        <div v-show="activeTab === 'library'">
          <h2 class="text-xl font-bold mb-4 text-gray-800">üìö Media Library</h2>

          <!-- Add Folder Section -->
          <div class="mb-6 p-4 bg-gray-50 rounded-lg">
            <h3 class="font-semibold mb-3 text-gray-700">Add Media Folder</h3>
            <form @submit.prevent="addFolder" class="flex gap-2">
              <input v-model="folderPath" type="text" placeholder="Enter folder path (e.g., C:\Users\Username\Videos)"
                class="flex-1 px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500"
                required />
              <button type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded transition"
                :disabled="isScanning">
                {{ isScanning ? 'Scanning...' : 'Scan Folder' }}
              </button>
            </form>
            <p v-if="scanMessage" class="mt-2 text-sm"
              :class="scanMessage.type === 'error' ? 'text-red-600' : 'text-green-600'">
              {{ scanMessage.text }}
            </p>
          </div>

          <!-- Filter Buttons -->
          <div class="mb-4 flex gap-2">
            <button @click="mediaFilter = 'all'" :class="[
                'px-4 py-2 rounded transition',
                mediaFilter === 'all'
                  ? 'bg-indigo-600 text-white'
                  : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
              ]">
              All ({{ mediaLibrary.length }})
            </button>
            <button @click="mediaFilter = 'image'" :class="[
                'px-4 py-2 rounded transition',
                mediaFilter === 'image'
                  ? 'bg-indigo-600 text-white'
                  : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
              ]">
              Images ({{ filteredMedia.filter(m => m.fileType === 'image').length }})
            </button>
            <button @click="mediaFilter = 'video'" :class="[
                'px-4 py-2 rounded transition',
                mediaFilter === 'video'
                  ? 'bg-indigo-600 text-white'
                  : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
              ]">
              Videos ({{ filteredMedia.filter(m => m.fileType === 'video').length }})
            </button>
          </div>

          <!-- Media Grid -->
          <div v-if="filteredMedia.length > 0"
            class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            <div v-for="media in filteredMedia" :key="media.id"
              class="media-card bg-white border border-gray-200 rounded-lg overflow-hidden">
              <!-- Thumbnail -->
              <div class="relative h-48 bg-gray-200 cursor-pointer group" @click="openPlayModal(media)">
                <img :src="media.thumbnailUrl" :alt="media.filename"
                  class="w-full h-full object-cover transition group-hover:opacity-90" />
                <div
                  class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                  <span class="bg-black bg-opacity-50 text-white px-3 py-1 rounded-full text-sm">Use Media</span>
                </div>
                <div class="absolute top-2 left-2 bg-black bg-opacity-70 text-white text-xs px-2 py-1 rounded">
                  {{ media.fileType === 'video' ? 'üé• Video' : 'üñºÔ∏è Image' }}
                </div>
                <div v-if="media.duration"
                  class="absolute bottom-2 right-2 bg-black bg-opacity-70 text-white text-xs px-2 py-1 rounded">
                  {{ formatDuration(media.duration) }}
                </div>
              </div>

              <!-- Info -->
              <div class="p-3">
                <p class="font-semibold text-sm text-gray-800 truncate" :title="media.filename">
                  {{ media.filename }}
                </p>
                <p class="text-xs text-gray-500 mt-1">
                  Owner: {{ media.owner.username }}
                  <span :class="media.owner.isOnline ? 'text-green-500' : 'text-gray-400'">‚óè</span>
                </p>
                <button @click="openPlayModal(media)"
                  class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white py-2 rounded transition flex items-center justify-center gap-2">
                  <span>‚ñ∂</span> Play
                </button>
              </div>
            </div>
          </div>
          <div v-else class="text-center py-12 text-gray-500">
            <p class="text-lg">No media files found</p>
            <p class="text-sm mt-2">Add a folder to start sharing media!</p>
          </div>
        </div>

        <!-- Send Message Tab -->
        <div v-show="activeTab === 'message'">
          <h2 class="text-xl font-bold mb-4 text-gray-800">üì§ Send Message</h2>

          <form @submit.prevent="sendMessage" class="space-y-4">
            <div>
              <label class="block text-gray-700 font-semibold mb-2">Text</label>
              <textarea v-model="messageText"
                class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500"
                rows="4" placeholder="Enter your message..."></textarea>
            </div>

            <div>
              <label class="block text-gray-700 font-semibold mb-2">URL (Optional)</label>
              <input v-model="messageUrl" type="url"
                class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500"
                placeholder="https://example.com/image.jpg" />
            </div>

            <button type="submit"
              class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded transition">
              Send Message
            </button>
          </form>

          <p v-if="messageStatus" class="mt-4 text-center"
            :class="messageStatus.type === 'error' ? 'text-red-600' : 'text-green-600'">
            {{ messageStatus.text }}
          </p>
        </div>

        <!-- Text-to-Speech Tab -->
        <div v-show="activeTab === 'tts'">
          <h2 class="text-xl font-bold mb-4 text-gray-800">üé§ Text-to-Speech</h2>

          <form @submit.prevent="speak" class="space-y-4">
            <div>
              <label class="block text-gray-700 font-semibold mb-2">Text to Speak</label>
              <textarea v-model="ttsText"
                class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500"
                rows="6" placeholder="Enter text to convert to speech..." required></textarea>
            </div>

            <button type="submit"
              class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded transition"
              :disabled="isSpeaking">
              {{ isSpeaking ? 'Generating...' : 'Generate and Play' }}
            </button>
          </form>

          <p v-if="ttsStatus" class="mt-4 text-center"
            :class="ttsStatus.type === 'error' ? 'text-red-600' : 'text-green-600'">
            {{ ttsStatus.text }}
          </p>
        </div>

        <!-- Connected Users Tab -->
        <div v-show="activeTab === 'users'">
          <h2 class="text-xl font-bold mb-4 text-gray-800">üë• Connected Users</h2>

          <div v-if="onlineUsers.length > 0" class="space-y-2">
            <div v-for="user in onlineUsers" :key="user.userId"
              class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
              <div class="flex items-center gap-3">
                <span class="text-green-500 text-xl">‚óè</span>
                <div>
                  <p class="font-semibold text-gray-800">{{ user.username }}</p>
                  <p class="text-sm text-gray-500">{{ user.mediaCount || 0 }} media files</p>
                </div>
              </div>
            </div>
          </div>
          <div v-else class="text-center py-12 text-gray-500">
            <p class="text-lg">No other users online</p>
          </div>
        </div>
      </div>

      <!-- Floating Stop Button -->
      <button @click="stopCurrent"
        class="fixed bottom-6 right-6 bg-red-500 hover:bg-red-600 text-white w-16 h-16 rounded-full shadow-lg flex items-center justify-center text-2xl transition transform hover:scale-110"
        title="Stop Current Media">
        ‚èπ
      </button>
    </div>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          // Authentication
          isAuthenticated: false,
          isConnecting: false,
          username: '',
          userId: null,
          errorMessage: '',

          // Socket
          socket: null,

          // Tabs
          activeTab: 'library',
          tabs: [
            { id: 'library', name: 'Media Library', icon: 'üìö' },
            { id: 'message', name: 'Send Message', icon: 'üì§' },
            { id: 'tts', name: 'Text-to-Speech', icon: 'üé§' },
            { id: 'users', name: 'Users', icon: 'üë•' },
          ],

          // Media Library
          mediaLibrary: [],
          mediaFilter: 'all',
          folderPath: '',
          isScanning: false,
          scanMessage: null,

          // Send Message
          messageText: '',
          messageUrl: '',
          messageStatus: null,

          // Text-to-Speech
          ttsText: '',
          isSpeaking: false,
          ttsStatus: null,

          // Guild ID (shared across features)
          guildId: '1183396070823313418',

          // Online Users
          onlineUsers: [],

          // Play Modal
          selectedMedia: null,
          playText: '',
          mediaPos: { x: 0, y: 0, w: 100, h: 100 },
          dragState: null, // { type: 'move'|'resize', startX, startY, startPos, handle }
          mediaAspectRatio: 1.777, // Default 16:9
          canvasAspectRatio: 16 / 9,
        };
      },
      computed: {
        filteredMedia() {
          if (this.mediaFilter === 'all') {
            return this.mediaLibrary;
          }
          return this.mediaLibrary.filter(m => m.fileType === this.mediaFilter);
        },
      },
      watch: {
        // Reset position when media changes
        selectedMedia(newVal) {
          if (newVal) {
            this.fetchMediaDimensions(newVal);
          }
        }
      },
      mounted() {
        // Global event listeners for drag/resize
        window.addEventListener('mousemove', this.onDrag);
        window.addEventListener('mouseup', this.stopDrag);
      },
      beforeUnmount() {
        window.removeEventListener('mousemove', this.onDrag);
        window.removeEventListener('mouseup', this.stopDrag);
      },
      methods: {

        async fetchMediaDimensions(media) {
          // Default to full 16:9
          this.mediaAspectRatio = 16 / 9;

          // Construct safe URL for checking
          // Use filename or dummy to attempt to hint browser?
          // For simple metadata check, the ID route is fine.
          const streamUrl = `/admin/api/media/${media.id}/stream`;

          try {
            if (media.fileType === 'image') {
              const img = new Image();
              img.src = streamUrl;
              await new Promise((resolve) => {
                img.onload = () => {
                  this.mediaAspectRatio = img.naturalWidth / img.naturalHeight;
                  resolve();
                };
                img.onerror = resolve; // Fallback
              });
            } else if (media.fileType === 'video') {
              const video = document.createElement('video');
              video.src = streamUrl;
              await new Promise((resolve) => {
                video.onloadedmetadata = () => {
                  this.mediaAspectRatio = video.videoWidth / video.videoHeight;
                  resolve();
                };
                video.onerror = resolve; // Fallback
              });
            }
          } catch (e) {
            console.error("Failed to get dimensions", e);
          }

          // Initial "Fit" logic
          // We want to fit within the 100x100 box, centered
          // Calculate width/height in % relative to canvas
          // Ratio = w% / h% * (CanvasRatio)
          // h% = w% * (CanvasRatio / MediaRatio)

          // Start with Max Width 80%
          let w = 80;
          let h = w * (this.canvasAspectRatio / this.mediaAspectRatio);

          // If height exceeds 80%, scale down by height
          if (h > 80) {
            h = 80;
            w = h * (this.mediaAspectRatio / this.canvasAspectRatio);
          }

          // Center it
          const x = (100 - w) / 2;
          const y = (100 - h) / 2;

          this.mediaPos = {
            x: parseFloat(x.toFixed(1)),
            y: parseFloat(y.toFixed(1)),
            w: parseFloat(w.toFixed(1)),
            h: parseFloat(h.toFixed(1))
          };
        },

        applyPreset(type) {
          // Basic presets reset to specific percentages
          // Note: This might break aspect ratio, but user can resize to fix
          switch (type) {
            case 'fullscreen':
              this.mediaPos = { x: 0, y: 0, w: 100, h: 100 };
              break;
            case 'center':
              // Recalculate based on ratio for "Center Fit"?
              // Or just use the initial calculation logic again
              this.fetchMediaDimensions(this.selectedMedia);
              break;
            case 'corner-br':
              this.mediaPos = { x: 70, y: 70, w: 25, h: 25 }; // Arbitrary box
              break;
            case 'pip':
              this.mediaPos = { x: 75, y: 5, w: 20, h: 20 };
              break;
          }
        },

        startDrag(e) {
          if (e.target !== e.currentTarget) return; // Ignore if clicked on resize handle
          e.preventDefault();
          this.dragState = {
            type: 'move',
            startX: e.clientX,
            startY: e.clientY,
            startPos: { ...this.mediaPos }
          };
        },

        startResize(handle) {
          this.dragState = {
            type: 'resize',
            handle: handle,
            startX: window.event.clientX,
            startY: window.event.clientY,
            startPos: { ...this.mediaPos }
          };
        },

        onDrag(e) {
          if (!this.dragState) return;

          const container = this.$refs.canvasContainer;
          if (!container) return;

          const rect = container.getBoundingClientRect();
          const dxPx = e.clientX - this.dragState.startX;
          const dyPx = e.clientY - this.dragState.startY;

          // Convert pixels to percentages
          const dx = (dxPx / rect.width) * 100;
          const dy = (dyPx / rect.height) * 100;

          if (this.dragState.type === 'move') {
            let newX = this.dragState.startPos.x + dx;
            let newY = this.dragState.startPos.y + dy;

            // Constrain to bounds
            newX = Math.max(0, Math.min(100 - this.dragState.startPos.w, newX));
            newY = Math.max(0, Math.min(100 - this.dragState.startPos.h, newY));

            this.mediaPos.x = parseFloat(newX.toFixed(1));
            this.mediaPos.y = parseFloat(newY.toFixed(1));
          } else if (this.dragState.type === 'resize') {
            const { handle, startPos } = this.dragState;
            let newX = startPos.x;
            let newY = startPos.y;
            let newW = startPos.w;
            let newH = startPos.h;

            // Simple non-ratio resize logic first to get raw deltas
            // But we want to enforce ratio.
            // We drive by Width usually, unless N/S dragging (not possible with corners? yes corners have N/S component)

            // Let's decide driven dimension based on handle?
            // Actually, simply: 
            // 1. Calculate new Width based on mouse
            // 2. Calculate ideal Height based on Width + Ratio
            // 3. Adjust X/Y (if left/top handle)

            // Problem: if Height hits boundary before Width, we need to constrain Width.

            // It's complex to handle all 4 corners perfectly with ratio + bounds.
            // Simplified approach:
            // Calculate candidate NewW based on mouse X (for E/W handles)

            let candidateW = startPos.w;

            if (handle.includes('e')) candidateW = startPos.w + dx;
            else if (handle.includes('w')) candidateW = startPos.w - dx;

            // Min size
            if (candidateW < 5) candidateW = 5;

            // Calculate candidateH
            // w% / h% * C = M  => h% = w% * (C/M)
            let candidateH = candidateW * (this.canvasAspectRatio / this.mediaAspectRatio);

            // Now apply to X/Y
            let candidateX = startPos.x;
            let candidateY = startPos.y;

            if (handle.includes('w')) candidateX = startPos.x + (startPos.w - candidateW);
            if (handle.includes('n')) {
              // For North handles, Y changes. 
              // We need to check if Y shift matches H change? 
              // Actually, if we drive by Width, the Height is derived.
              // So if I drag Top-Left, I move Mouse. 
              // NewW based on X. NewH based on NewW. 
              // NewY = OldY + (OldH - NewH).
              candidateY = startPos.y + (startPos.h - candidateH);
            } else if (handle.includes('s')) {
              // South, Y is fixed?
              // candidateY = startPos.y; // Correct
            }

            // Check bounds
            // X < 0
            if (candidateX < 0) {
              // constrained left.
              candidateX = 0;
              candidateW = startPos.x + startPos.w; // Max width available? No.
              // If dragging 'w', X pinned to 0. W can't grow left.
              // If dragging 'e', X is fixed startPos.x.

              // This bounds logic gets messy. 
              // Let's just create valid candidates and clamp them?
              // If simple clamp fails ratio, we have to clamp the other one too.
            }

            // Let's just update and see? It's better than nothing.
            // Improved logic:

            if (handle.includes('w')) {
              newW = startPos.w - dx;
              if (newW < 5) newW = 5;
              // Calc H
              newH = newW * (this.canvasAspectRatio / this.mediaAspectRatio);

              newX = startPos.x + (startPos.w - newW);
              newY = startPos.y + (startPos.h - newH); // Assume center resize? No, corner.

              if (handle.includes('n')) {
                // NW: X and Y move.
                newY = startPos.y + (startPos.h - newH);
              } else {
                // SW: X moves, Y fixed? No, H changes. Y fixed for Top? 
                // SW corner: Top is fixed. Y stays same.
                newY = startPos.y;
              }
            } else { // 'e'
              newW = startPos.w + dx;
              if (newW < 5) newW = 5;
              newH = newW * (this.canvasAspectRatio / this.mediaAspectRatio);
              newX = startPos.x;

              if (handle.includes('n')) {
                // NE: Y moves
                newY = startPos.y + (startPos.h - newH);
              } else {
                // SE: Y fixed
                newY = startPos.y;
              }
            }

            // Final check that we didn't drift wildly?
            this.mediaPos = {
              x: parseFloat(newX.toFixed(1)),
              y: parseFloat(newY.toFixed(1)),
              w: parseFloat(newW.toFixed(1)),
              h: parseFloat(newH.toFixed(1))
            };
          }
        },

        stopDrag() {
          this.dragState = null;
        },

        /**
         * Authenticate and connect to Socket.IO
         */
        async authenticate() {
          if (!this.username.trim()) {
            this.errorMessage = 'Please enter a username';
            return;
          }

          this.isConnecting = true;
          this.errorMessage = '';

          try {
            // Connect to Socket.IO
            this.socket = io(window.location.origin);

            // Wait for connection
            await new Promise((resolve, reject) => {
              this.socket.on('connect', resolve);
              this.socket.on('connect_error', reject);
              setTimeout(() => reject(new Error('Connection timeout')), 10000);
            });

            // Register as admin user
            this.socket.emit('admin:register', {
              username: this.username,
            });

            // Wait for registration confirmation
            await new Promise((resolve, reject) => {
              this.socket.once('admin:registered', (data) => {
                this.userId = data.userId;
                resolve();
              });
              this.socket.once('admin:error', (data) => {
                reject(new Error(data.message));
              });
              setTimeout(() => reject(new Error('Registration timeout')), 10000);
            });

            // Set up event listeners
            this.setupSocketListeners();

            // Load media library
            await this.loadMediaLibrary();

            this.isAuthenticated = true;
          } catch (error) {
            console.error('Authentication error:', error);
            this.errorMessage = error.message || 'Failed to connect';
            if (this.socket) {
              this.socket.disconnect();
              this.socket = null;
            }
          } finally {
            this.isConnecting = false;
          }
        },

        /**
         * Set up Socket.IO event listeners
         */
        setupSocketListeners() {
          // Media added by other users
          this.socket.on('admin:media-added', (data) => {
            console.log('New media added:', data);
            if (data.media && Array.isArray(data.media)) {
              this.mediaLibrary.push(...data.media);
            }
          });

          // User online
          this.socket.on('admin:user-online', (data) => {
            console.log('User online:', data);
            if (!this.onlineUsers.find(u => u.userId === data.userId)) {
              this.onlineUsers.push({
                userId: data.userId,
                username: data.username,
                mediaCount: 0,
              });
            }
          });

          // User offline
          this.socket.on('admin:user-offline', (data) => {
            console.log('User offline:', data);
            const index = this.onlineUsers.findIndex(u => u.userId === data.userId);
            if (index !== -1) {
              this.onlineUsers.splice(index, 1);
            }
          });

          // Stream request from another user
          this.socket.on('admin:stream-request', (data) => {
            this.handleStreamRequest(data);
          });

          // Error handling
          this.socket.on('admin:error', (data) => {
            console.error('Socket error:', data);
            alert(`Error: ${data.message}`);
          });
        },

        /**
         * Load media library from server
         */
        async loadMediaLibrary() {
          try {
            const response = await fetch('/admin/api/media');
            const result = await response.json();

            if (result.success) {
              this.mediaLibrary = result.data;
            }
          } catch (error) {
            console.error('Failed to load media library:', error);
          }
        },

        /**
         * Add a folder and scan for media
         */
        async addFolder() {
          if (!this.folderPath.trim()) {
            return;
          }

          this.isScanning = true;
          this.scanMessage = null;

          try {
            // Emit scan-folder event
            this.socket.emit('admin:scan-folder', {
              userId: this.userId,
              folderPath: this.folderPath.trim(),
            });

            // Wait for completion
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => reject(new Error('Scan timeout')), 60000);

              this.socket.once('admin:scan-complete', (data) => {
                clearTimeout(timeout);
                this.scanMessage = {
                  type: 'success',
                  text: `Successfully added ${data.mediaCount} media files!`,
                };
                resolve();
              });

              this.socket.once('admin:error', (data) => {
                clearTimeout(timeout);
                this.scanMessage = {
                  type: 'error',
                  text: data.message || 'Failed to scan folder',
                };
                reject(new Error(data.message));
              });
            });

            // Reload media library
            await this.loadMediaLibrary();

            // Clear folder path
            this.folderPath = '';
          } catch (error) {
            console.error('Folder scan error:', error);
            if (!this.scanMessage) {
              this.scanMessage = {
                type: 'error',
                text: error.message || 'Failed to scan folder',
              };
            }
          } finally {
            this.isScanning = false;
          }
        },

        /**
         * Open Play Modal
         */
        openPlayModal(media) {
          this.selectedMedia = media;
          this.playText = '';
          // Focus textarea next tick
          this.$nextTick(() => {
            if (this.$refs.playInput) this.$refs.playInput.focus();
          });
        },

        closePlayModal() {
          this.selectedMedia = null;
          this.playText = '';
        },

        confirmPlay() {
          if (!this.selectedMedia) return;
          this.playMedia(this.selectedMedia, this.playText);
          this.closePlayModal();
        },

        /**
         * Play a media item
         */
        playMedia(media, text = null) {
          this.socket.emit('admin:play-media', {
            mediaId: media.id,
            requesterId: this.userId,
            guildId: this.guildId,
            displayFull: true,
            layout: this.mediaPos,
            text: text,
          });

          // Show feedback
          this.socket.once('admin:play-success', () => {
            alert(`Playing: ${media.filename}`);
          });
        },

        /**
         * Handle stream request from another user
         */
        handleStreamRequest(data) {
          const { mediaId, requesterId, guildId } = data;

          // Find the media item
          const media = this.mediaLibrary.find(m => m.id === mediaId);
          if (!media) {
            return;
          }

          // Generate stream URL
          const streamUrl = `${window.location.origin}/admin/api/admin/media/${mediaId}/stream`;

          // Send response
          this.socket.emit('admin:stream-response', {
            mediaId,
            requesterId,
            guildId,
            streamUrl,
          });

          console.log(`Provided stream for ${media.filename} to user ${requesterId}`);
        },

        /**
         * Send a text/media message
         */
        sendMessage() {
          if (!this.messageText.trim() && !this.messageUrl.trim()) {
            this.messageStatus = {
              type: 'error',
              text: 'Please enter text or URL',
            };
            return;
          }

          this.socket.emit('admin:send-message', {
            userId: this.userId,
            guildId: this.guildId,
            text: this.messageText.trim() || null,
            url: this.messageUrl.trim() || null,
          });

          this.socket.once('admin:message-sent', () => {
            this.messageStatus = {
              type: 'success',
              text: 'Message sent successfully!',
            };
            this.messageText = '';
            this.messageUrl = '';

            setTimeout(() => {
              this.messageStatus = null;
            }, 3000);
          });
        },

        /**
         * Generate and play text-to-speech
         */
        speak() {
          if (!this.ttsText.trim()) {
            return;
          }

          this.isSpeaking = true;
          this.ttsStatus = null;

          this.socket.emit('admin:speak', {
            userId: this.userId,
            guildId: this.guildId,
            text: this.ttsText.trim(),
            voice: 'fr',
          });

          this.socket.once('admin:speak-success', () => {
            this.ttsStatus = {
              type: 'success',
              text: 'Speech generated and queued!',
            };
            this.ttsText = '';
            this.isSpeaking = false;

            setTimeout(() => {
              this.ttsStatus = null;
            }, 3000);
          });

          this.socket.once('admin:error', () => {
            this.isSpeaking = false;
          });
        },

        /**
         * Stop current media
         */
        stopCurrent() {
          this.socket.emit('admin:stop', {
            guildId: this.guildId,
          });

          this.socket.once('admin:stop-success', () => {
            console.log('Media stopped');
          });
        },

        /**
         * Format duration in seconds to MM:SS
         */
        formatDuration(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        },

        /**
         * Logout and disconnect
         */
        logout() {
          if (this.socket) {
            this.socket.disconnect();
          }

          this.isAuthenticated = false;
          this.userId = null;
          this.username = '';
          this.mediaLibrary = [];
          this.onlineUsers = [];
        },
      },
    }).mount('#app');
  </script>
</body>

</html>